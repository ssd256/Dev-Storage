### Array vs ArrayList vs LinkedList

세 자료구조를 한 줄로 정의하면,

* Array : index 기반으로 빠르게 값을 찾을 수 있음
* ArrayList : index 기반으로 데이터를 빠르게 찾을 수 있지만 삽입/삭제가 느림
* LinkedList : 데이터의 삽입/삭제가 빠르지만 ArrayList에 비해 조회가 느림



![ArrayList 구조]()

![LinkedList 구조3]()



배열(Array)은 **선언 시 크기와 데이터 타입을 지정** 해야 한다. 

```java
int arr[20];
String[] str = new String[6];
```

**배열**은 공간의 크기를 줄이거나 키우는 게 불가능하고, **다시 공간을 할당**해야 한다.

그리고 데이터를 중간에 삽입하거나 삭제할 경우에도 새로운 공간을 할당하고 기존 값과 삽입/삭제된 값들을 넣기 때문에 메모리도 낭비되고 비효율적이다. 

선언 시 정한 타입 외에는 다른 타입의 데이터는 넣을 수 없으니 여러 데이터 타입을 저장할 때에는 타입의 수만큼 배열을 만들어야 한다.

단, index를 기반으로 데이터가 저장되므로 특정 값을 찾을 때 빠르게 찾을 수 있다.



데이터의 **크기를 알 수 없거나 여러 데이터 타입을 넣고 싶을 때**는 **ArrayList**를 사용한다.

arrayList는 크기가 정해져 있지 않고 순서대로 저장되기 때문에 array의 문제를 해결하고 여러 타입의 데이터를 저장할 수 있다. index 기반이라서 검색도 빠르다.

하지만 중간에 값을 삽입/삭제하는 경우에는 array처럼 기존 데이터를 밀거나 당겨서 공간을 만들어야 하므로 시간이 오래걸리는 단점이 있다.



중간에 **데이터의 삽입/삭제**를 하고 싶다면 **LinkedList**를 사용한다.

연결리스트에는 단일, 양방향, 이중 원형 등이 존재하며, 기본 원리는 **한 노드에 연결된 노드가 다음 노드의 대한 주소값을 가진다**는 점이다. 

각 노드들이 다음 노드에 대한 주소값을 가지고 있어서 데이터의 삽입/삭제 시 전체를 돌지 않아도 이전 값과 다음 값이 가르키는 주소값만 수정하여 연결시키면 되기 때문에 처리속도가 빠르다. 

하지만 `n번째 값 찾기`일 때는 비효율적이다.

array이나 arrayList는 index 기반이라 순차적으로 저장되어 특정 값의 위치를 빠르게 검색할 수 있지만, LinkedList는 처음부터 검색해야 하므로 상대적으로 검색에 시간이 오래걸린다.



**결론**

* 상황에 맞게 자료구조를 사용하는 것이 좋다. 빠른 조회가 필요한지, 중간에 데이터 삽입/삭제가 자주 일어나는지 등에 따라 알맞게 활용하는 것이 좋다. 